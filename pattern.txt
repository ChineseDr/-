继承 实线 空三角  ——▷
实现 虚线 空三角  ----▷   (圆圈 o————)
关联(持有对象) 实线 箭头   ————>
聚合(弱从属)   虚线 空心菱形(被组成) 箭头(组成个体)  ◇————>
合成(强从属)   实线 实心菱形   箭头 ◆————>
依赖 虚线箭头   ---->

设计模式原则：
	一、单一职责原则：	
	二、开放封闭原则：拓展是开放的，更改是封闭的
	三、依赖倒置原则：
		1.高层模块不依赖底层模块，不论高层模块还是底层模块都只依赖抽象(接口)，依赖终止于接口
		2.抽象不依赖细节，细节依赖抽象，
	四、里氏替换原则：子类型必须能替换它的父类
	五、迪米特法则：两个类不用直接通信，那么这两个类就不应该互相作用，如果需要调用就一个类的方法就通过第三方转发这个调用
	六、


模式分类：
	一、简单工厂：封装思想，解耦(封装隔离)
	
	二、策略模式：一系列算法完成相同的工作
	
	三、装饰模式：给一个对象增加功能
	
	四、代理模式：代理和真实体实现共同接口，代理持有一个引用指向真实体
		模式应用
			1.远程代理
			2.虚拟代理
			2.安全代理
			
	五、工厂模式：(类似IOC/DI)较简单工厂符合开放-封闭原则
	
	六、原型模式：从一个对象创建另外一个可定制对象，且不需要知道任何细节，把不可变的重复行为抽取出来放在公共父类中
	
	
	七、模板方法模式：定义一个操作中的算法的骨架，二将一些步骤延迟到子类实现，(父类把某些步骤抽象，由子类实现)
					  使得子类可以不改变算法结构即可以重新定义该算法的某些特步骤
	
	
	八、外观模式：为子系统的一组接口提供一个统一的界面（高层接口）外观类知道具体哪个子系统处理客户端请求
	
	
	九、建造者模式：(抽象模板)复杂对象的构建与它的表示分开，同样的创建过程可以创建不同的表示；
					仅需指定类型就可以得到对象，创建过程和细节不需要知道
	
	十、观察者模式：一(被观察者)对多(观察者)关系，多个观察者监听某一对象的变化，这个对象变化时会通知所有观察者对象(通知调用观察者的更新)，观察者接到通知后自己更新自己
					一个对象改变时同时需要改变不知道还有多少其他对象，>>解耦<<
	
	十一、抽象工厂模式：提供一个创建 一系列相关或互相依赖 对象的接口，无需指定他们的类型
					抽象工厂( IFactory ) ==> 多个具体工厂( FactoryA  FactoryB )
					抽象产品A( abstractProductA )==>多个不同的具体产品( ProductA1  ProductA2 )
					抽象产品B( abstractProductB )==>多个不同的具体产品( ProductB1  ProductB2 )
					为创建特定产品创建不同工厂，不同工厂生产不同的具体产品，把工厂抽象
	
	十二、状态模式：状态判断复杂，把状态判断转移到表示 不同这状态 的一系列类中，
					状态抽象，一系列表示不同状态的类，持有状态实例维护不同状态
	
	十三、适配器模式：将一个类的接口转换成另外一个希望的接口，
					  使得原本因接口不兼容而不能在一起工作的类可以一起工作
	
	
	十四、备忘录模式：在不破坏封装的情况下，捕获一个对象的内部状态，并在对象之外保存这个状态，
					  这样以后就可以将该对象恢复到原先保存的状态
				
				Originator：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可以使用备忘录恢复内部状态，
							Originato可以根据需要决定Memento存储Originator
				
				Memento：负责存储Originator内部状态，Memento有两个接口，Caretaker只能访问它的窄接口，只负责将备忘录传递给其他对象，
						Originator能够访问它的宽接口，可以访问Memento并回到先前状态
				
				Caretaker：负责保存Memento，不能对Memento进行操作和检查
						
	
	
	十五、组合模式：将对象组合成树形以表示“部分-整体”的层次结构
					Component
					Composite
	
	十六、迭代器模式
	
	十七、单例模式
	
	十八、桥接模式
	
	十九、命令模式
	
	二十、职责模式
	
	二十一、中介者模式
	
	二十二、享元模式
	
	二十三、解释器模式
	
	二十四、访问者模式
